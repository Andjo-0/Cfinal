#All code is generated by chatGPT
import csv
import random
from dataclasses import dataclass
from typing import List, Optional, Tuple
import matplotlib.pyplot as plt
import numpy as np


# Code is generated by chatgpt with modifications for early stopping without a fixed iteration limit

@dataclass
class City:
    name: str
    north: float
    east: float


@dataclass
class CityDist:
    city1: City
    city2: City
    distance_cost: float
    pheromone: float = 1.0  # Default initial pheromone


@dataclass
class Ant:
    current_city: City
    visited_cities: List[City]


def read_cities(filepath: str) -> List[City]:
    """
    Reads cities from a CSV file.
    The CSV is expected to have headers: City;North;East
    """
    cities = []
    with open(filepath, newline='', encoding='latin1') as csvfile:
        reader = csv.DictReader(csvfile, delimiter=';')
        for row in reader:
            try:
                city = City(
                    name=row['City'],
                    north=float(row['North']),
                    east=float(row['East'])
                )
                cities.append(city)
            except ValueError as e:
                print(f"Error converting row {row}: {e}")
    return cities


def plot_cities(cities: List[City], tour: Optional[List[City]] = None):
    """
    Plots the city locations.
    If a tour (ordered list of cities) is provided, it draws lines connecting them.
    """
    plt.figure(figsize=(10, 8))
    # Plot each city as a blue circle with annotation
    for city in cities:
        plt.scatter(city.east, city.north, c='blue', marker='o', zorder=3)
        plt.annotate(city.name, (city.east, city.north), textcoords="offset points",
                     xytext=(5, 5), ha='left', fontsize=8)
    # If a tour is provided, draw the route
    if tour:
        for i in range(len(tour)):
            city_from = tour[i]
            city_to = tour[(i + 1) % len(tour)]  # Wrap around to start
            plt.plot([city_from.east, city_to.east], [city_from.north, city_to.north],
                     'r-', linewidth=2, zorder=2)
    plt.xlabel("East")
    plt.ylabel("North")
    plt.title("City Locations and Best Tour")
    plt.grid(True, zorder=0)
    plt.show()


def euclidean_distance(city1: City, city2: City) -> float:
    """Computes the Euclidean distance between two cities."""
    return np.sqrt((city2.east - city1.east) ** 2 + (city2.north - city1.north) ** 2)


def cost_all_cities(cities: List[City]) -> List[CityDist]:
    """
    Creates a list of CityDist objects for every unique pair of cities.
    """
    cost_cities = []
    for i, city1 in enumerate(cities):
        for j in range(i + 1, len(cities)):
            city2 = cities[j]
            distance = euclidean_distance(city1, city2)
            cost_cities.append(CityDist(city1, city2, distance))
    return cost_cities


def find_city_dist(city_dists: List[CityDist], city1: City, city2: City) -> Optional[CityDist]:
    """
    Finds the CityDist record for the given pair of cities.
    """
    return next((cd for cd in city_dists
                 if (cd.city1 == city1 and cd.city2 == city2) or (cd.city1 == city2 and cd.city2 == city1)),
                None)


def calculate_tour_cost(tour: List[City], city_dists: List[CityDist]) -> float:
    """Calculates the total cost of the given tour (including returning to the start)."""
    total_cost = 0.0
    for i in range(len(tour) - 1):
        edge = find_city_dist(city_dists, tour[i], tour[i + 1])
        total_cost += edge.distance_cost
    # Add cost to return to the start to complete the cycle
    edge = find_city_dist(city_dists, tour[-1], tour[0])
    total_cost += edge.distance_cost
    return total_cost


def ant_colony_optimization(
        cities: List[City],
        city_dists: List[CityDist],
        num_ants: int,
        alpha: float,
        beta: float,
        evaporation_rate: float,
        stagnation_limit: int = 10  # Stop if no improvement for 10 consecutive iterations
) -> Tuple[List[City], float]:
    """
    Runs the Ant Colony Optimization algorithm with early stopping based on stagnation.
    The algorithm runs until there is no improvement for 'stagnation_limit' consecutive iterations.

    Parameters:
      - cities: List of City objects.
      - city_dists: List of CityDist objects representing all edges.
      - num_ants: Number of ants per iteration.
      - alpha: Weight for pheromone.
      - beta: Weight for heuristic (1/distance).
      - evaporation_rate: Rate at which pheromone evaporates.
      - stagnation_limit: Number of consecutive iterations with no improvement to trigger convergence.

    Returns:
      - best_tour: The best tour (ordered list of cities) found.
      - best_cost: The cost of the best tour.
    """
    best_tour = []
    best_cost = float('inf')
    stagnant_counter = 0
    previous_best_cost = float('inf')
    iteration = 0

    while stagnant_counter < stagnation_limit:
        iteration += 1
        ants: List[Ant] = []
        # Initialize ants at random starting cities
        for _ in range(num_ants):
            start_city = random.choice(cities)
            ants.append(Ant(current_city=start_city, visited_cities=[start_city]))

        # Each ant builds a complete tour
        for ant in ants:
            while len(ant.visited_cities) < len(cities):
                available_cities = [city for city in cities if city not in ant.visited_cities]
                attractiveness = []
                total_attractiveness = 0.0

                # Calculate attractiveness for each available city
                for city in available_cities:
                    edge = find_city_dist(city_dists, ant.current_city, city)
                    # Avoid division by zero if distance is extremely small
                    heuristic = 1.0 / edge.distance_cost if edge.distance_cost > 0 else 0.0
                    attr = (edge.pheromone ** alpha) * (heuristic ** beta)
                    attractiveness.append(attr)
                    total_attractiveness += attr

                # Roulette wheel selection for next city
                r = random.random()
                cumulative = 0.0
                next_city = available_cities[-1]  # Default in case of numerical issues
                for idx, city in enumerate(available_cities):
                    cumulative += attractiveness[idx] / total_attractiveness
                    if r <= cumulative:
                        next_city = city
                        break

                ant.visited_cities.append(next_city)
                ant.current_city = next_city

            # Compute the cost of this ant's tour
            tour_cost = calculate_tour_cost(ant.visited_cities, city_dists)
            if tour_cost < best_cost:
                best_cost = tour_cost
                best_tour = ant.visited_cities.copy()

        # Pheromone Evaporation
        for edge in city_dists:
            edge.pheromone *= (1 - evaporation_rate)

        # Pheromone Update based on each ant's tour quality
        for ant in ants:
            tour_cost = calculate_tour_cost(ant.visited_cities, city_dists)
            deposit_amount = 1.0 / tour_cost  # Better tours deposit more pheromone
            # Deposit pheromone along the tour edges
            for i in range(len(ant.visited_cities) - 1):
                edge = find_city_dist(city_dists, ant.visited_cities[i], ant.visited_cities[i + 1])
                edge.pheromone += deposit_amount
            # Deposit pheromone for the return edge to complete the cycle
            edge = find_city_dist(city_dists, ant.visited_cities[-1], ant.visited_cities[0])
            edge.pheromone += deposit_amount

        print(f"Iteration {iteration}, best tour cost so far: {best_cost:.2f}")

        # Check for convergence: if no improvement compared to previous iteration, increment counter.
        if best_cost < previous_best_cost:
            stagnant_counter = 0
        else:
            stagnant_counter += 1

        previous_best_cost = best_cost

    print(
        f"No improvement for {stagnation_limit} consecutive iterations. Convergence achieved after {iteration} iterations.")
    return best_tour, best_cost


def main():
    filepath = "data/byerFixed.csv"  # Adjust the path if necessary
    cities = read_cities(filepath)

    if not cities:
        print("No cities loaded!")
        return

    # Calculate all pair distances
    city_dists = cost_all_cities(cities)

    # Run Ant Colony Optimization with specified parameters
    num_ants = 100
    alpha = 1.0  # Influence of pheromone
    beta = 2.0  # Influence of heuristic (1/distance)
    evaporation_rate = 0.5
    stagnation_limit = 10  # Stop if no improvement for 10 consecutive iterations

    best_tour, best_cost = ant_colony_optimization(
        cities, city_dists, num_ants, alpha, beta, evaporation_rate, stagnation_limit
    )

    print("Best tour found:")
    for city in best_tour:
        print(city.name, end=" -> ")
    print(best_tour[0].name)  # To show the return to the starting city
    print(f"Tour cost: {best_cost:.2f}")

    # Plot cities and the best tour
    plot_cities(cities, best_tour)


if __name__ == "__main__":
    main()
